<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advanced Audio Noise Removal Tool (MP3, M4A, OGG, WAV)</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
background-image: url('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSFVOZ2CsKQIPT0Lk06f5bNALaBIuEhMWppBg&s');
    color: red;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1rem;
    min-height: 100vh;
  }
  h1 {
    margin-bottom: 0.5rem;
  }
  input[type="file"] {
    margin: 1rem 0;
background: rgba(0, 0, 0, 0.5)
  }
  label {
    display: block;
    margin: 1rem 0 0.25rem;
  }
  input[type="range"] {
    width: 300px;
background: rgba(0, 0, 0, 0.5)
  }
  button {
    background: red;
    border: none;
    padding: 0.75rem 1.5rem;
    border-radius: 20px;
    color: green;
    font-weight: bold;
    cursor: pointer;
    margin: 1rem 0;
    transition: background 0.3s ease;
  }
  button:disabled {
background: rgba(0, 0, 0, 0.5)
    cursor: not-allowed;
  }
  button:hover:not(:disabled) {
background: rgba(0, 0, 0, 0.5)
  }
  audio {
    margin-top: 1rem;
    outline: none;
    width: 100%;
    max-width: 400px;
  }
  .container {
    max-width: 600px;
    width: 100%;
background: rgba(0, 0, 0, 0.5)
    border-radius: 10px;
    padding: 1.5rem;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
  }
  .footer {
    margin-top: 3rem;
    font-size: 0.8rem;
    color: red;
    max-width: 600px;
    text-align: center;
  }
</style>
</head>
<body>
<div class="container">
  <h1>Advanced Audio Noise Removal</h1>
  <input type="file" id="audioFile" accept=".mp3, .m4a, .ogg, .wav, audio/*" />
  
  <label for="thresholdRange">Noise Gate Threshold (dB): <span id="thresholdValue">-60</span></label>
  <input type="range" id="thresholdRange" min="-100" max="0" value="-60" />
  
  <button id="processBtn" disabled>Process & Remove Noise</button>
  
  <label>Original Audio</label>
  <audio id="originalAudio" controls></audio>
  
  <label>Processed Audio</label>
  <audio id="processedAudio" controls></audio>
  
  <button id="downloadBtn" disabled>Download Cleaned Audio (WAV)</button>
</div>

<div class="footer">
  Noise removal is done with a noise gate filter using Web Audio API. Works with MP3, M4A, OGG, WAV files fully offline.
</div>

<script>
  const audioFileInput = document.getElementById('audioFile');
  const processBtn = document.getElementById('processBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const thresholdRange = document.getElementById('thresholdRange');
  const thresholdValue = document.getElementById('thresholdValue');
  const originalAudio = document.getElementById('originalAudio');
  const processedAudio = document.getElementById('processedAudio');

  let audioContext;
  let originalBuffer;
  let processedBuffer;

  thresholdRange.addEventListener('input', () => {
    thresholdValue.textContent = thresholdRange.value;
  });

  audioFileInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    reset();

    originalAudio.src = URL.createObjectURL(file);
    originalAudio.load();

    audioContext = new (window.AudioContext || window.webkitAudioContext)();

    try {
      const arrayBuffer = await file.arrayBuffer();
      originalBuffer = await audioContext.decodeAudioData(arrayBuffer);
      processBtn.disabled = false;
    } catch (error) {
      alert('Error decoding audio file. Please upload a valid audio format (MP3, M4A, OGG, WAV).');
      reset();
    }
  });

  processBtn.addEventListener('click', async () => {
    if (!originalBuffer) return;
    processBtn.disabled = true;
    downloadBtn.disabled = true;
    processedAudio.src = '';
    processedAudio.load();

    processedBuffer = applyNoiseGate(originalBuffer, parseFloat(thresholdRange.value));

    // Create WAV blob for playback and download
    const wavBlob = bufferToWave(processedBuffer, processedBuffer.length);
    const wavUrl = URL.createObjectURL(wavBlob);

    processedAudio.src = wavUrl;
    processedAudio.load();

    downloadBtn.href = wavUrl;
    downloadBtn.download = 'cleaned_audio.wav';
    downloadBtn.disabled = false;

    processBtn.disabled = false;
  });

  downloadBtn.addEventListener('click', () => {
    // No extra logic needed, download handled by href and download attribute
  });

  // Noise gate function: reduces amplitude below threshold to zero
  function applyNoiseGate(audioBuffer, thresholdDb) {
    const sampleRate = audioBuffer.sampleRate;
    const channels = audioBuffer.numberOfChannels;
    const length = audioBuffer.length;
    const outputBuffer = audioContext.createBuffer(channels, length, sampleRate);

    // Convert dB threshold to linear amplitude
    const thresholdLinear = Math.pow(10, thresholdDb / 20);

    for (let ch = 0; ch < channels; ch++) {
      const inputData = audioBuffer.getChannelData(ch);
      const outputData = outputBuffer.getChannelData(ch);

      for (let i = 0; i < length; i++) {
        const sample = inputData[i];
        // If sample amplitude below threshold, reduce it to zero (noise gate)
        outputData[i] = Math.abs(sample) < thresholdLinear ? 0 : sample;
      }
    }
    return outputBuffer;
  }

  // Converts an AudioBuffer to a WAV Blob
  function bufferToWave(abuffer, len) {
    const numOfChan = abuffer.numberOfChannels,
      length = len * numOfChan * 2 + 44,
      buffer = new ArrayBuffer(length),
      view = new DataView(buffer),
      channels = [],
      sampleRate = abuffer.sampleRate,
      bitsPerSample = 16;

    // Write WAV header
    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    // RIFF chunk descriptor
    writeString(view, 0, 'RIFF');
    view.setUint32(4, length - 8, true);
    writeString(view, 8, 'WAVE');
    // fmt sub-chunk
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true); // chunk size
    view.setUint16(20, 1, true); // PCM format
    view.setUint16(22, numOfChan, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * numOfChan * bitsPerSample / 8, true);
    view.setUint16(32, numOfChan * bitsPerSample / 8, true);
    view.setUint16(34, bitsPerSample, true);
    // data sub-chunk
    writeString(view, 36, 'data');
    view.setUint32(40, length - 44, true);

    // Write interleaved data
    for (let i = 0; i < numOfChan; i++)
      channels.push(abuffer.getChannelData(i));

    let offset = 44;
    for (let i = 0; i < len; i++) {
      for (let ch = 0; ch < numOfChan; ch++) {
        // Clamp samples to -1..1
        let sample = Math.max(-1, Math.min(1, channels[ch][i]));
        // Scale to 16-bit signed int
        sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
        view.setInt16(offset, sample, true);
        offset += 2;
      }
    }

    return new Blob([buffer], { type: 'audio/wav' });
  }

  function reset() {
    processBtn.disabled = true;
    downloadBtn.disabled = true;
    processedAudio.src = '';
    processedAudio.load();
  }
</script>
</body>
</html>
