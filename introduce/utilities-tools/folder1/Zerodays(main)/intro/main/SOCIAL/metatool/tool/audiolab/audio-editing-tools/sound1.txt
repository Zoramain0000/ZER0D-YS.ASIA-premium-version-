<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Sound Mastering Tool</title>
    <link rel="stylesheet" href="style.css">
    <style>
/* CSS Reset and Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    background: #121212;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Header */
header {
    background: #1a1a1a;
    padding: 1.5rem 0;
    text-align: center;
    border-bottom: 2px solid #3a86ff;
}

header h1 {
    font-size: 2rem;
    font-weight: 700;
    color: #3a86ff;
    text-shadow: 0 2px 4px rgba(58, 134, 255, 0.3);
}

/* Main Content */
main {
    flex: 1;
    width: 90vw;
    max-width: 1200px;
    margin: 2rem auto;
    padding: 2rem;
    background: #222;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
}

/* Sections */
section {
    margin-bottom: 2.5rem;
    padding: 1.5rem;
    background: #2a2a2a;
    border-radius: 8px;
    border: 1px solid #333;
}

section h3 {
    color: #3a86ff;
    margin-bottom: 1rem;
    font-size: 1.2rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Controls Section */
.controls-section {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
}

.file-upload {
    position: relative;
}

.file-upload input[type="file"] {
    position: absolute;
    opacity: 0;
    width: 0;
    height: 0;
}

.file-label {
    display: inline-block;
    background: linear-gradient(135deg, #3a86ff, #2563eb);
    color: white;
    padding: 0.75rem 1.5rem;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s ease;
    border: 2px solid transparent;
}

.file-label:hover {
    background: linear-gradient(135deg, #2563eb, #1d4ed8);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(58, 134, 255, 0.4);
}

.playback-controls {
    display: flex;
    gap: 1rem;
}

/* Buttons */
button {
    background: linear-gradient(135deg, #3a86ff, #2563eb);
    border: none;
    color: white;
    padding: 0.75rem 1.5rem;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.95rem;
    transition: all 0.3s ease;
    border: 2px solid transparent;
}

button:hover:not(:disabled) {
    background: linear-gradient(135deg, #2563eb, #1d4ed8);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(58, 134, 255, 0.4);
}

button:disabled {
    background: #555;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

/* Audio Element */
.audio-section {
    padding: 1rem;
}

audio {
    width: 100%;
    border-radius: 6px;
    background: #333;
}

/* Slider Containers */
.slider-container {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.slider-container label {
    font-weight: 600;
    color: #ccc;
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Range Sliders */
input[type="range"] {
    -webkit-appearance: none;
    width: 100%;
    height: 8px;
    border-radius: 4px;
    background: #444;
    outline: none;
    cursor: pointer;
    transition: background 0.3s ease;
}

input[type="range"]:hover {
    background: #555;
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: linear-gradient(135deg, #3a86ff, #2563eb);
    cursor: pointer;
    border-radius: 50%;
    border: 2px solid #fff;
    box-shadow: 0 2px 8px rgba(58, 134, 255, 0.4);
    transition: all 0.3s ease;
}

input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(58, 134, 255, 0.6);
}

input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: linear-gradient(135deg, #3a86ff, #2563eb);
    cursor: pointer;
    border-radius: 50%;
    border: 2px solid #fff;
    box-shadow: 0 2px 8px rgba(58, 134, 255, 0.4);
}

/* Value Displays */
.value-display {
    color: #3a86ff;
    font-weight: 600;
    font-size: 0.85rem;
    text-align: center;
    min-width: 60px;
}

/* Equalizer */
.eq-controls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1.5rem;
}

.eq-band {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    padding: 1rem;
    background: #333;
    border-radius: 6px;
    border: 1px solid #444;
}

.eq-band label {
    font-weight: 700;
    color: #fff;
    font-size: 0.9rem;
}

.frequency {
    color: #888;
    font-size: 0.8rem;
    font-weight: 500;
}

/* Effects Section */
.effects-toggles {
    display: flex;
    flex-wrap: wrap;
    gap: 2rem;
    justify-content: center;
}

.effect-toggle {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    cursor: pointer;
    padding: 1rem;
    background: #333;
    border-radius: 6px;
    border: 1px solid #444;
    transition: all 0.3s ease;
}

.effect-toggle:hover {
    background: #3a3a3a;
    border-color: #3a86ff;
}

.effect-toggle input[type="checkbox"] {
    display: none;
}

.toggle-slider {
    position: relative;
    width: 50px;
    height: 24px;
    background: #555;
    border-radius: 12px;
    transition: background 0.3s ease;
}

.toggle-slider::before {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    width: 20px;
    height: 20px;
    background: #ccc;
    border-radius: 50%;
    transition: all 0.3s ease;
}

.effect-toggle input[type="checkbox"]:checked + .toggle-slider {
    background: #3a86ff;
}

.effect-toggle input[type="checkbox"]:checked + .toggle-slider::before {
    transform: translateX(26px);
    background: #fff;
}

.effect-name {
    font-weight: 600;
    color: #eee;
    font-size: 0.95rem;
}

/* Bitcrusher Controls */
.bitcrusher-controls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 2rem;
}

/* Status Display */
.status-display {
    background: #333;
    padding: 1rem;
    border-radius: 6px;
    border: 1px solid #444;
    text-align: center;
    font-weight: 500;
    color: #ccc;
}

/* Footer */
footer {
    background: #1a1a1a;
    padding: 1rem;
    text-align: center;
    color: #888;
    font-size: 0.9rem;
    border-top: 1px solid #333;
}

/* Responsive Design */
@media (max-width: 768px) {
    main {
        width: 95vw;
        padding: 1rem;
        margin: 1rem auto;
    }
    
    header h1 {
        font-size: 1.5rem;
    }
    
    .controls-section {
        flex-direction: column;
        align-items: stretch;
    }
    
    .eq-controls {
        grid-template-columns: 1fr;
    }
    
    .effects-toggles {
        flex-direction: column;
        gap: 1rem;
    }
    
    .bitcrusher-controls {
        grid-template-columns: 1fr;
    }
}

@media (max-width: 480px) {
    section {
        padding: 1rem;
    }
    
    .eq-band {
        padding: 0.75rem;
    }
    
    .effect-toggle {
        padding: 0.75rem;
    }
}

    </style>
</head>
<body>
    <header>
        <h1>Advanced Sound Mastering Tool</h1>
    </header>
    
    <main>
        <!-- File Upload and Playback Controls -->
        <section class="controls-section">
            <div class="file-upload">
                <input type="file" id="audioFile" accept="audio/*">
                <label for="audioFile" class="file-label">Choose Audio File</label>
            </div>
            <div class="playback-controls">
                <button id="playPause" disabled>Play</button>
                <button id="saveBtn" disabled>Save Processed Audio</button>
            </div>
        </section>

        <!-- Audio Element -->
        <section class="audio-section">
            <audio id="audio" controls></audio>
        </section>

        <!-- Volume Control -->
        <section class="volume-section">
            <h3>Volume Control</h3>
            <div class="slider-container">
                <label for="volume">Volume</label>
                <input type="range" id="volume" min="0" max="2" step="0.01" value="1">
                <span class="value-display" id="volumeValue">100%</span>
            </div>
        </section>

        <!-- Equalizer -->
        <section class="equalizer-section">
            <h3>5-Band Equalizer</h3>
            <div class="eq-controls">
                <div class="eq-band">
                    <label for="eqBass">Bass</label>
                    <span class="frequency">60Hz</span>
                    <input type="range" id="eqBass" min="-30" max="30" step="0.1" value="0">
                    <span class="value-display" id="eqBassValue">0dB</span>
                </div>
                <div class="eq-band">
                    <label for="eqLowMid">Low Mid</label>
                    <span class="frequency">250Hz</span>
                    <input type="range" id="eqLowMid" min="-30" max="30" step="0.1" value="0">
                    <span class="value-display" id="eqLowMidValue">0dB</span>
                </div>
                <div class="eq-band">
                    <label for="eqMid">Mid</label>
                    <span class="frequency">1kHz</span>
                    <input type="range" id="eqMid" min="-30" max="30" step="0.1" value="0">
                    <span class="value-display" id="eqMidValue">0dB</span>
                </div>
                <div class="eq-band">
                    <label for="eqHighMid">High Mid</label>
                    <span class="frequency">4kHz</span>
                    <input type="range" id="eqHighMid" min="-30" max="30" step="0.1" value="0">
                    <span class="value-display" id="eqHighMidValue">0dB</span>
                </div>
                <div class="eq-band">
                    <label for="eqTreble">Treble</label>
                    <span class="frequency">10kHz</span>
                    <input type="range" id="eqTreble" min="-30" max="30" step="0.1" value="0">
                    <span class="value-display" id="eqTrebleValue">0dB</span>
                </div>
            </div>
        </section>

        <!-- Audio Effects -->
        <section class="effects-section">
            <h3>Audio Effects</h3>
            <div class="effects-toggles">
                <label class="effect-toggle">
                    <input type="checkbox" id="compressorToggle">
                    <span class="toggle-slider"></span>
                    <span class="effect-name">Compressor</span>
                </label>
                <label class="effect-toggle">
                    <input type="checkbox" id="reverbToggle">
                    <span class="toggle-slider"></span>
                    <span class="effect-name">Reverb</span>
                </label>
                <label class="effect-toggle">
                    <input type="checkbox" id="bitcrusherToggle">
                    <span class="toggle-slider"></span>
                    <span class="effect-name">Bitcrusher</span>
                </label>
            </div>
        </section>

        <!-- Bitcrusher Settings -->
        <section class="bitcrusher-section">
            <h3>Bitcrusher Settings</h3>
            <div class="bitcrusher-controls">
                <div class="slider-container">
                    <label for="bitDepth">Bit Depth</label>
                    <input type="range" id="bitDepth" min="1" max="16" step="1" value="8">
                    <span class="value-display" id="bitDepthValue">8 bits</span>
                </div>
                <div class="slider-container">
                    <label for="frequencyReduction">Frequency Reduction</label>
                    <input type="range" id="frequencyReduction" min="1" max="20" step="1" value="4">
                    <span class="value-display" id="frequencyReductionValue">4x</span>
                </div>
            </div>
        </section>

        <!-- Status Display -->
        <section class="status-section">
            <div class="status-display" id="statusDisplay">
                Ready to load audio file
            </div>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Sound Mastering Tool - Fully Client-Side Audio Processing</p>
    </footer>

    <script src="script.js">
class AudioMasteringTool {
    constructor() {
        this.audioCtx = null;
        this.sourceNode = null;
        this.gainNode = null;
        this.eqNodes = [];
        this.compressorNode = null;
        this.convolverNode = null;
        this.bitcrusherNode = null;
        this.audioBuffer = null;
        this.isPlaying = false;
        
        this.initializeElements();
        this.attachEventListeners();
        this.updateStatusDisplay('Ready to load audio file');
    }
    
    initializeElements() {
        // Main elements
        this.audioElement = document.getElementById('audio');
        this.fileInput = document.getElementById('audioFile');
        this.playPauseBtn = document.getElementById('playPause');
        this.saveBtn = document.getElementById('saveBtn');
        this.statusDisplay = document.getElementById('statusDisplay');
        
        // Volume control
        this.volumeSlider = document.getElementById('volume');
        this.volumeValue = document.getElementById('volumeValue');
        
        // Equalizer sliders
        this.eqSliders = {
            bass: document.getElementById('eqBass'),
            lowMid: document.getElementById('eqLowMid'),
            mid: document.getElementById('eqMid'),
            highMid: document.getElementById('eqHighMid'),
            treble: document.getElementById('eqTreble')
        };
        
        // EQ value displays
        this.eqValues = {
            bass: document.getElementById('eqBassValue'),
            lowMid: document.getElementById('eqLowMidValue'),
            mid: document.getElementById('eqMidValue'),
            highMid: document.getElementById('eqHighMidValue'),
            treble: document.getElementById('eqTrebleValue')
        };
        
        // Effects toggles
        this.effectToggles = {
            compressor: document.getElementById('compressorToggle'),
            reverb: document.getElementById('reverbToggle'),
            bitcrusher: document.getElementById('bitcrusherToggle')
        };
        
        // Bitcrusher controls
        this.bitDepthSlider = document.getElementById('bitDepth');
        this.frequencyReductionSlider = document.getElementById('frequencyReduction');
        this.bitDepthValue = document.getElementById('bitDepthValue');
        this.frequencyReductionValue = document.getElementById('frequencyReductionValue');
    }
    
    attachEventListeners() {
        // File input
        this.fileInput.addEventListener('change', (e) => this.handleFileLoad(e));
        
        // Playback controls
        this.playPauseBtn.addEventListener('click', () => this.togglePlay());
        this.saveBtn.addEventListener('click', () => this.saveProcessedAudio());
        
        // Volume control
        this.volumeSlider.addEventListener('input', () => this.updateVolume());
        
        // Equalizer controls
        Object.keys(this.eqSliders).forEach(key => {
            this.eqSliders[key].addEventListener('input', () => this.updateEQ());
        });
        
        // Effects toggles
        Object.values(this.effectToggles).forEach(toggle => {
            toggle.addEventListener('change', () => this.updateAudioGraph());
        });
        
        // Bitcrusher controls
        this.bitDepthSlider.addEventListener('input', () => {
            this.updateBitcrusherDisplay();
            if (this.effectToggles.bitcrusher.checked) {
                this.updateAudioGraph();
            }
        });
        
        this.frequencyReductionSlider.addEventListener('input', () => {
            this.updateBitcrusherDisplay();
            if (this.effectToggles.bitcrusher.checked) {
                this.updateAudioGraph();
            }
        });
        
        // Audio element events
        this.audioElement.addEventListener('play', () => {
            this.playPauseBtn.textContent = 'Pause';
            this.isPlaying = true;
        });
        
        this.audioElement.addEventListener('pause', () => {
            this.playPauseBtn.textContent = 'Play';
            this.isPlaying = false;
        });
        
        this.audioElement.addEventListener('ended', () => {
            this.playPauseBtn.textContent = 'Play';
            this.isPlaying = false;
        });
        
        // Initialize displays
        this.updateVolumeDisplay();
        this.updateEQDisplays();
        this.updateBitcrusherDisplay();
    }
    
    async handleFileLoad(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        try {
            this.updateStatusDisplay('Loading audio file...');
            
            // Close existing audio context
            if (this.audioCtx) {
                await this.audioCtx.close();
            }
            
            // Create new audio context
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Load file into audio element
            this.audioElement.src = URL.createObjectURL(file);
            
            // Decode audio data for processing
            const arrayBuffer = await file.arrayBuffer();
            this.audioBuffer = await this.audioCtx.decodeAudioData(arrayBuffer);
            
            // Enable controls
            this.playPauseBtn.disabled = false;
            this.saveBtn.disabled = false;
            
            // Setup audio graph
            this.updateAudioGraph();
            
            this.updateStatusDisplay(`Loaded: ${file.name} (${this.formatDuration(this.audioBuffer.duration)})`);
            
        } catch (error) {
            console.error('Error loading audio file:', error);
            this.updateStatusDisplay('Error loading audio file. Please try a different file.');
        }
    }
    
    createEQFilters() {
        const bands = [
            { freq: 60, type: 'lowshelf' },
            { freq: 250, type: 'peaking' },
            { freq: 1000, type: 'peaking' },
            { freq: 4000, type: 'peaking' },
            { freq: 10000, type: 'highshelf' }
        ];
        
        return bands.map(band => {
            const filter = this.audioCtx.createBiquadFilter();
            filter.type = band.type;
            filter.frequency.value = band.freq;
            filter.Q.value = band.type === 'peaking' ? 1.0 : 0.7;
            filter.gain.value = 0;
            return filter;
        });
    }
    
    createCompressor() {
        const compressor = this.audioCtx.createDynamicsCompressor();
        compressor.threshold.setValueAtTime(-24, this.audioCtx.currentTime);
        compressor.knee.setValueAtTime(30, this.audioCtx.currentTime);
        compressor.ratio.setValueAtTime(12, this.audioCtx.currentTime);
        compressor.attack.setValueAtTime(0.003, this.audioCtx.currentTime);
        compressor.release.setValueAtTime(0.25, this.audioCtx.currentTime);
        return compressor;
    }
    
    createReverb() {
        const convolver = this.audioCtx.createConvolver();
        const irBuffer = this.audioCtx.createBuffer(2, this.audioCtx.sampleRate * 3, this.audioCtx.sampleRate);
        
        for (let channel = 0; channel < irBuffer.numberOfChannels; channel++) {
            const channelData = irBuffer.getChannelData(channel);
            for (let i = 0; i < channelData.length; i++) {
                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / channelData.length, 2);
            }
        }
        
        convolver.buffer = irBuffer;
        return convolver;
    }
    
    createBitcrusher() {
        const bitDepth = parseInt(this.bitDepthSlider.value);
        const frequencyReduction = parseInt(this.frequencyReductionSlider.value);
        
        const processor = this.audioCtx.createScriptProcessor(4096, 1, 1);
        let phaser = 0;
        let lastSampleValue = 0;
        
        processor.onaudioprocess = (e) => {
            const input = e.inputBuffer.getChannelData(0);
            const output = e.outputBuffer.getChannelData(0);
            
            for (let i = 0; i < input.length; i++) {
                phaser += frequencyReduction;
                if (phaser >= 1.0) {
                    phaser -= 1.0;
                    const step = Math.pow(0.5, bitDepth);
                    lastSampleValue = step * Math.floor(input[i] / step + 0.5);
                }
                output[i] = lastSampleValue;
            }
        };
        
        return processor;
    }
    
    updateAudioGraph() {
        if (!this.audioCtx || !this.audioBuffer) return;
        
        try {
            // Disconnect existing nodes
            if (this.sourceNode) {
                this.sourceNode.disconnect();
            }
            
            // Create media element source
            this.sourceNode = this.audioCtx.createMediaElementSource(this.audioElement);
            
            // Create gain node
            this.gainNode = this.audioCtx.createGain();
            this.gainNode.gain.value = parseFloat(this.volumeSlider.value);
            
            // Create EQ nodes
            this.eqNodes = this.createEQFilters();
            
            // Start with source
            let currentNode = this.sourceNode;
            
            // Connect EQ chain
            this.eqNodes.forEach(eqNode => {
                currentNode.connect(eqNode);
                currentNode = eqNode;
            });
            
            // Add compressor if enabled
            if (this.effectToggles.compressor.checked) {
                this.compressorNode = this.createCompressor();
                currentNode.connect(this.compressorNode);
                currentNode = this.compressorNode;
            }
            
            // Add reverb if enabled
            if (this.effectToggles.reverb.checked) {
                this.convolverNode = this.createReverb();
                currentNode.connect(this.convolverNode);
                currentNode = this.convolverNode;
            }
            
            // Add bitcrusher if enabled
            if (this.effectToggles.bitcrusher.checked) {
                this.bitcrusherNode = this.createBitcrusher();
                currentNode.connect(this.bitcrusherNode);
                currentNode = this.bitcrusherNode;
            }
            
            // Connect to gain and destination
            currentNode.connect(this.gainNode);
            this.gainNode.connect(this.audioCtx.destination);
            
            // Update EQ settings
            this.updateEQ();
            
        } catch (error) {
            console.error('Error updating audio graph:', error);
            this.updateStatusDisplay('Error updating audio processing chain');
        }
    }
    
    updateVolume() {
        const value = parseFloat(this.volumeSlider.value);
        if (this.gainNode) {
            this.gainNode.gain.value = value;
        }
        this.updateVolumeDisplay();
    }
    
    updateVolumeDisplay() {
        const value = parseFloat(this.volumeSlider.value);
        this.volumeValue.textContent = `${Math.round(value * 100)}%`;
    }
    
    updateEQ() {
        if (this.eqNodes.length === 0) return;
        
        const values = [
            parseFloat(this.eqSliders.bass.value),
            parseFloat(this.eqSliders.lowMid.value),
            parseFloat(this.eqSliders.mid.value),
            parseFloat(this.eqSliders.highMid.value),
            parseFloat(this.eqSliders.treble.value)
        ];
        
        values.forEach((value, index) => {
            if (this.eqNodes[index]) {
                this.eqNodes[index].gain.value = value;
            }
        });
        
        this.updateEQDisplays();
    }
    
    updateEQDisplays() {
        const sliders = Object.values(this.eqSliders);
        const displays = Object.values(this.eqValues);
        
        sliders.forEach((slider, index) => {
            const value = parseFloat(slider.value);
            const sign = value >= 0 ? '+' : '';
            displays[index].textContent = `${sign}${value.toFixed(1)}dB`;
        });
    }
    
    updateBitcrusherDisplay() {
        this.bitDepthValue.textContent = `${this.bitDepthSlider.value} bits`;
        this.frequencyReductionValue.textContent = `${this.frequencyReductionSlider.value}x`;
    }
    
    togglePlay() {
        if (!this.audioElement.src) return;
        
        if (this.audioCtx && this.audioCtx.state === 'suspended') {
            this.audioCtx.resume();
        }
        
        if (this.audioElement.paused) {
            this.audioElement.play();
        } else {
            this.audioElement.pause();
        }
    }
    
    async saveProcessedAudio() {
        if (!this.audioBuffer) {
            this.updateStatusDisplay('No audio loaded to save');
            return;
        }
        
        try {
            this.updateStatusDisplay('Processing audio for export...');
            
            // Create offline context for rendering
            const offlineCtx = new OfflineAudioContext(
                this.audioBuffer.numberOfChannels,
                this.audioBuffer.length,
                this.audioBuffer.sampleRate
            );
            
            // Create offline source
            const offlineSource = offlineCtx.createBufferSource();
            offlineSource.buffer = this.audioBuffer;
            
            // Create offline gain
            const offlineGain = offlineCtx.createGain();
            offlineGain.gain.value = parseFloat(this.volumeSlider.value);
            
            // Create offline EQ
            const offlineEQ = this.createOfflineEQ(offlineCtx);
            
            // Connect offline chain
            let currentNode = offlineSource;
            
            // Connect EQ
            offlineEQ.forEach(eqNode => {
                currentNode.connect(eqNode);
                currentNode = eqNode;
            });
            
            // Add effects if enabled
            if (this.effectToggles.compressor.checked) {
                const offlineCompressor = this.createOfflineCompressor(offlineCtx);
                currentNode.connect(offlineCompressor);
                currentNode = offlineCompressor;
            }
            
            if (this.effectToggles.reverb.checked) {
                const offlineReverb = this.createOfflineReverb(offlineCtx);
                currentNode.connect(offlineReverb);
                currentNode = offlineReverb;
            }
            
            // Connect to gain and destination
            currentNode.connect(offlineGain);
            offlineGain.connect(offlineCtx.destination);
            
            // Start rendering
            offlineSource.start(0);
            const renderedBuffer = await offlineCtx.startRendering();
            
            // Convert to WAV and download
            const wavBlob = this.audioBufferToWav(renderedBuffer);
            const url = URL.createObjectURL(wavBlob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'processed_audio.wav';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            this.updateStatusDisplay('Audio exported successfully');
            
        } catch (error) {
            console.error('Error saving audio:', error);
            this.updateStatusDisplay('Error exporting audio');
        }
    }
    
    createOfflineEQ(ctx) {
        const bands = [
            { freq: 60, type: 'lowshelf' },
            { freq: 250, type: 'peaking' },
            { freq: 1000, type: 'peaking' },
            { freq: 4000, type: 'peaking' },
            { freq: 10000, type: 'highshelf' }
        ];
        
        const sliders = Object.values(this.eqSliders);
        
        return bands.map((band, index) => {
            const filter = ctx.createBiquadFilter();
            filter.type = band.type;
            filter.frequency.value = band.freq;
            filter.Q.value = band.type === 'peaking' ? 1.0 : 0.7;
            filter.gain.value = parseFloat(sliders[index].value);
            return filter;
        });
    }
    
    createOfflineCompressor(ctx) {
        const compressor = ctx.createDynamicsCompressor();
        compressor.threshold.setValueAtTime(-24, ctx.currentTime);
        compressor.knee.setValueAtTime(30, ctx.currentTime);
        compressor.ratio.setValueAtTime(12, ctx.currentTime);
        compressor.attack.setValueAtTime(0.003, ctx.currentTime);
        compressor.release.setValueAtTime(0.25, ctx.currentTime);
        return compressor;
    }
    
    createOfflineReverb(ctx) {
        const convolver = ctx.createConvolver();
        const irBuffer = ctx.createBuffer(2, ctx.sampleRate * 3, ctx.sampleRate);
        
        for (let channel = 0; channel < irBuffer.numberOfChannels; channel++) {
            const channelData = irBuffer.getChannelData(channel);
            for (let i = 0; i < channelData.length; i++) {
                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / channelData.length, 2);
            }
        }
        
        convolver.buffer = irBuffer;
        return convolver;
    }
    
    audioBufferToWav(buffer) {
        const length = buffer.length;
        const numberOfChannels = buffer.numberOfChannels;
        const sampleRate = buffer.sampleRate;
        const arrayBuffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
        const view = new DataView(arrayBuffer);
        
        // WAV header
        const writeString = (offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };
        
        writeString(0, 'RIFF');
        view.setUint32(4, 36 + length * numberOfChannels * 2, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numberOfChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numberOfChannels * 2, true);
        view.setUint16(32, numberOfChannels * 2, true);
        view.setUint16(34, 16, true);
        writeString(36, 'data');
        view.setUint32(40, length * numberOfChannels * 2, true);
        
        // Convert audio data
        let offset = 44;
        for (let i = 0; i < length; i++) {
            for (let channel = 0; channel < numberOfChannels; channel++) {
                const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                view.setInt16(offset, sample * 0x7FFF, true);
                offset += 2;
            }
        }
        
        return new Blob([arrayBuffer], { type: 'audio/wav' });
    }
    
    formatDuration(seconds) {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
    
    updateStatusDisplay(message) {
        this.statusDisplay.textContent = message;
    }
}

// Initialize the application when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new AudioMasteringTool();
});

    </script>
</body>
</html>
