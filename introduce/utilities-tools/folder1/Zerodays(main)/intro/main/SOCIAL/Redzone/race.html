<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Top-Down Racing Game</title>
<style>
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  body {
background-image: url('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSFVOZ2CsKQIPT0Lk06f5bNALaBIuEhMWppBg&s');
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: red;
    user-select: none;
  }
  canvas {
background: rgba(0, 0, 0, 0.5);
    border: 3px solid red;
    border-radius: 10px;
    display: block;
    background-image:
      linear-gradient(to bottom, red 2px, transparent 2px),
      linear-gradient(to right, red 10px, transparent 10px);
    background-size: 100% 40px, 40px 100%;
  }
  #ui {
    position: absolute;
    top: 20px;
    left: 20px;
    font-size: 20px;
    background: rgba(0,0,0,0.5);
    padding: 12px 16px;
    border-radius: 8px;
  }
  #ui span {
    margin-right: 20px;
  }
  #instructions {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: #ccc;
    font-size: 14px;
    background: rgba(0,0,0,0.5);
    padding: 8px 12px;
    border-radius: 6px;
  }
</style>
</head>
<body>

<canvas id="game" width="400" height="600"></canvas>
<div id="ui">
  <span id="score">Score: 0</span>
  <span id="boost">Boost: Ready</span>
</div>
<div id="instructions">
  Use arrow keys to move. Press SPACE for speed boost.
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const W = canvas.width;
  const H = canvas.height;

  // Game constants
  const roadWidth = 200;
  const laneCount = 3;
  const laneWidth = roadWidth / laneCount;
  const roadLeftX = (W - roadWidth) / 2;
  const maxSpeed = 6;
  const boostSpeed = 12;
  const boostDuration = 1500; // ms
  const boostCooldown = 4000; // ms
  const obstacleSize = 40;

  // Player car
  const player = {
    lane: 1, // 0,1,2 for lanes
    y: H - 120,
    width: laneWidth * 0.7,
    height: 90,
    color: '#00ff44',
    speed: 0,
    baseSpeed: 4,
    boosting: false,
    boostTimer: 0,
    boostCooldownTimer: 0
  };

  // Obstacles array
  let obstacles = [];

  // Score & distance
  let score = 0;
  let distance = 0;

  // Controls state
  const keys = {};

  // Timing for obstacle spawning
  let obstacleSpawnTimer = 0;
  const obstacleSpawnInterval = 1200; // ms

  // Road scroll
  let roadOffset = 0;

  // Utility: Draw rounded rect
  function roundedRect(ctx, x, y, w, h, r, fillStyle) {
    ctx.fillStyle = fillStyle;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    ctx.fill();
  }

  // Draw player car
  function drawPlayer() {
    const x = roadLeftX + player.lane * laneWidth + laneWidth/2 - player.width/2;
    ctx.fillStyle = player.color;
    roundedRect(ctx, x, player.y, player.width, player.height, 15, player.color);
    // windows detail
    ctx.fillStyle = '#222';
    ctx.fillRect(x + player.width*0.2, player.y + 15, player.width*0.6, player.height*0.3);
  }

  // Draw obstacles
  function drawObstacles() {
    obstacles.forEach(ob => {
      const x = roadLeftX + ob.lane * laneWidth + laneWidth/2 - obstacleSize/2;
      ctx.fillStyle = ob.color;
      roundedRect(ctx, x, ob.y, obstacleSize, obstacleSize, 10, ob.color);
      // obstacle detail: stripes
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x+10, ob.y+10);
      ctx.lineTo(x+30, ob.y+30);
      ctx.moveTo(x+30, ob.y+10);
      ctx.lineTo(x+10, ob.y+30);
      ctx.stroke();
    });
  }

  // Draw road lines
  function drawRoad() {
    // gray road
    ctx.fillStyle = '#555';
    ctx.fillRect(roadLeftX, 0, roadWidth, H);

    // lane lines
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    for(let i = 1; i < laneCount; i++) {
      let x = roadLeftX + i * laneWidth;
      ctx.setLineDash([30, 30]);
      ctx.beginPath();
      ctx.moveTo(x, roadOffset % 60 - 60);
      ctx.lineTo(x, H);
      ctx.stroke();
    }
    ctx.setLineDash([]);

    // road border lines
    ctx.strokeStyle = '#fffb';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(roadLeftX, 0);
    ctx.lineTo(roadLeftX, H);
    ctx.moveTo(roadLeftX + roadWidth, 0);
    ctx.lineTo(roadLeftX + roadWidth, H);
    ctx.stroke();
  }

  // Draw UI text
  function updateUI() {
    document.getElementById('score').textContent = `Score: ${Math.floor(score)}`;
    const boostEl = document.getElementById('boost');
    if (player.boosting) {
      boostEl.textContent = 'Boost: Active!';
      boostEl.style.color = '#0f0';
    } else if (player.boostCooldownTimer > 0) {
      boostEl.textContent = `Boost: Cooldown ${(player.boostCooldownTimer/1000).toFixed(1)}s`;
      boostEl.style.color = '#ffa500';
    } else {
      boostEl.textContent = 'Boost: Ready';
      boostEl.style.color = '#0ff';
    }
  }

  // Spawn new obstacles
  function spawnObstacle() {
    const lane = Math.floor(Math.random() * laneCount);
    const colors = ['#ff4d4d', '#ffb84d', '#ff4da6'];
    obstacles.push({
      lane,
      y: -obstacleSize,
      color: colors[Math.floor(Math.random() * colors.length)],
      speed: player.baseSpeed + Math.random() * 2
    });
  }

  // Update obstacles position, remove off-screen, detect collisions
  function updateObstacles(delta) {
    for (let i = obstacles.length - 1; i >= 0; i--) {
      obstacles[i].y += (player.speed + obstacles[i].speed) * delta * 0.06;
      // collision check with player
      if (obstacles[i].y + obstacleSize > player.y &&
          obstacles[i].y < player.y + player.height) {
        const playerX = roadLeftX + player.lane * laneWidth + laneWidth/2;
        const obX = roadLeftX + obstacles[i].lane * laneWidth + laneWidth/2;
        if (Math.abs(playerX - obX) < laneWidth/2) {
          // Collision - game over
          gameOver();
        }
      }
      if (obstacles[i].y > H) {
        obstacles.splice(i, 1);
        score += 10;
      }
    }
  }

  // Handle game over
  let isGameOver = false;
  function gameOver() {
    isGameOver = true;
    alert(`Game Over! Your score: ${Math.floor(score)}`);
    resetGame();
  }

  // Reset game state
  function resetGame() {
    obstacles = [];
    score = 0;
    distance = 0;
    player.lane = 1;
    player.speed = player.baseSpeed;
    player.boosting = false;
    player.boostTimer = 0;
    player.boostCooldownTimer = 0;
    roadOffset = 0;
    isGameOver = false;
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  }

  // Handle input
  window.addEventListener('keydown', e => {
    if (e.repeat) return;
    keys[e.code] = true;
    if (e.code === 'ArrowLeft') {
      player.lane = Math.max(0, player.lane - 1);
    } else if (e.code === 'ArrowRight') {
      player.lane = Math.min(laneCount -1, player.lane + 1);
    } else if (e.code === 'Space') {
      activateBoost();
    }
  });
  window.addEventListener('keyup', e => {
    keys[e.code] = false;
  });

  // Boost activation
  function activateBoost() {
    if (!player.boosting && player.boostCooldownTimer <= 0) {
      player.boosting = true;
      player.boostTimer = boostDuration;
    }
  }

  let lastTime = performance.now();

  // Game loop
  function gameLoop(timestamp) {
    if (isGameOver) return;
    const delta = timestamp - lastTime;
    lastTime = timestamp;

    ctx.clearRect(0, 0, W, H);

    // Road offset for scrolling effect
    roadOffset += player.speed * delta * 0.06;
    if (roadOffset > 60) roadOffset -= 60;

    drawRoad();

    // Boost timer update
    if (player.boosting) {
      player.boostTimer -= delta;
      player.speed = boostSpeed;
      if (player.boostTimer <= 0) {
        player.boosting = false;
        player.boostCooldownTimer = boostCooldown;
        player.speed = player.baseSpeed;
      }
    } else if (player.boostCooldownTimer > 0) {
      player.boostCooldownTimer -= delta;
      if (player.boostCooldownTimer < 0) player.boostCooldownTimer = 0;
      player.speed = player.baseSpeed;
    } else {
      player.speed = player.baseSpeed;
    }

    // Spawn obstacles over time
    obstacleSpawnTimer += delta;
    if (obstacleSpawnTimer > obstacleSpawnInterval) {
      obstacleSpawnTimer = 0;
      spawnObstacle();
    }

    updateObstacles(delta);
    drawObstacles();
    drawPlayer();

    distance += player.speed * delta * 0.01;
    score += player.speed * delta * 0.005;

    updateUI();

    requestAnimationFrame(gameLoop);
  }

  // Start game
  resetGame();
})();
</script>

</body>
</html>
